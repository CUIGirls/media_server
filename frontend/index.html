<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Optimized P2P Movie Streaming Platform</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 2rem;
      font-size: 2.5rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .search-container {
      background: white;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 30px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    
    .search-box {
      display: flex;
      gap: 10px;
    }
    
    #searchInput {
      flex: 1;
      padding: 15px;
      border: 2px solid #e1e5e9;
      border-radius: 10px;
      font-size: 16px;
      outline: none;
    }
    
    #searchBtn {
      padding: 15px 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    
    .status-panel {
      background: rgba(255,255,255,0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 30px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .status-item {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
    }
    
    .status-label {
      font-weight: bold;
      color: #667eea;
      font-size: 14px;
    }
    
    .status-value {
      margin-top: 5px;
      font-size: 16px;
    }
    
    .movies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 25px;
      margin-bottom: 30px;
    }
    
    .movie-card {
      background: rgba(255,255,255,0.95);
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      transition: transform 0.3s;
    }
    
    .movie-card:hover {
      transform: translateY(-5px);
    }
    
    .movie-card img {
      width: 100%;
      height: 300px;
      object-fit: cover;
    }
    
    .movie-info {
      padding: 20px;
    }
    
    .movie-title {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .movie-year {
      color: #667eea;
      margin-bottom: 10px;
    }
    
    .movie-summary {
      color: #666;
      line-height: 1.5;
      margin-bottom: 15px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    .download-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    
    .download-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .download-panel {
      background: rgba(255,255,255,0.95);
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 12px;
      background: #e9ecef;
      border-radius: 6px;
      overflow: hidden;
      margin: 20px 0 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      border-radius: 6px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .progress-text {
      text-align: center;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 20px;
    }
    
    .chunk-visualization {
      margin: 20px 0;
    }
    
    .chunk-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
      gap: 2px;
      max-width: 100%;
    }
    
    .chunk-item {
      width: 20px;
      height: 20px;
      border-radius: 2px;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    
    .chunk-missing { background: #dc3545; }
    .chunk-downloading { background: #ffc107; }
    .chunk-p2p { background: #007bff; }
    .chunk-server { background: #28a745; }
    
    .peer-list {
      margin: 15px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    
    .peer-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid #e9ecef;
    }
    
    .logs {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    
    .log-entry {
      margin-bottom: 5px;
      padding: 3px 0;
      word-wrap: break-word;
    }
    
    .log-info { color: #63b3ed; }
    .log-success { color: #68d391; }
    .log-warning { color: #fbd38d; }
    .log-error { color: #feb2b2; }
    .log-p2p { color: #a78bfa; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ Optimized P2P Movie Streaming Platform</h1>
    
    <div class="search-container">
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="Search for movies (e.g., Inception, Avengers)..." />
        <button id="searchBtn">üîç Search</button>
      </div>
    </div>
      <div class="status-panel">
      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">Connection Status</div>
          <div class="status-value" id="connectionStatus">Disconnected</div>
        </div>
        <div class="status-item">
          <div class="status-label">Peer ID</div>
          <div class="status-value" id="peerId">Not Connected</div>
        </div>
        <div class="status-item">
          <div class="status-label">Active Peers</div>
          <div class="status-value" id="activePeers">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">P2P Efficiency</div>
          <div class="status-value" id="p2pEfficiency">0%</div>
        </div>
        <div class="status-item">
          <div class="status-label">Download Speed</div>
          <div class="status-value" id="downloadSpeed">0 KB/s</div>
        </div>
        <div class="status-item">
          <div class="status-label">Download Progress</div>
          <div class="status-value" id="downloadProgress">0%</div>
        </div>
        <div class="status-item">
          <div class="status-label">CPU Utilization</div>
          <div class="status-value" id="cpuUtilization">0%</div>
        </div>
        <div class="status-item">
          <div class="status-label">Parallel Workers</div>
          <div class="status-value" id="activeWorkers">0/0</div>
        </div>
      </div>
    </div>

    <!-- Parallel Streaming Control Panel -->
    <div class="status-panel" id="parallelStreamingPanel" style="display: none;">
      <h3 style="color: #667eea; margin-bottom: 15px;">üöÄ Parallel Streaming Engine</h3>
      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">Streaming Status</div>
          <div class="status-value" id="streamingStatus">Idle</div>
        </div>
        <div class="status-item">
          <div class="status-label">Chunks Processed</div>
          <div class="status-value" id="chunksProcessed">0/0</div>
        </div>
        <div class="status-item">
          <div class="status-label">Buffer Health</div>
          <div class="status-value" id="bufferHealth">0%</div>
        </div>
        <div class="status-item">
          <div class="status-label">Processing Speed</div>
          <div class="status-value" id="processingSpeed">0 chunks/s</div>
        </div>
      </div>
      
      <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
        <button id="enableParallelBtn" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">
          üöÄ Enable Parallel Streaming
        </button>
        <button id="viewStatsBtn" style="padding: 10px 20px; background: #764ba2; color: white; border: none; border-radius: 8px; cursor: pointer;">
          üìä View Detailed Stats
        </button>
        <button id="optimizeBtn" style="padding: 10px 20px; background: #48bb78; color: white; border: none; border-radius: 8px; cursor: pointer;">
          ‚ö° Auto-Optimize
        </button>
      </div>
      
      <!-- Real-time Performance Metrics -->
      <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
        <h4 style="color: #667eea; margin-bottom: 10px;">‚ö° Real-time Performance</h4>
        <div id="performanceMetrics" class="status-grid">
          <div class="status-item">
            <div class="status-label">Bandwidth Usage</div>
            <div class="status-value" id="bandwidthUsage">0 Mbps</div>
          </div>
          <div class="status-item">
            <div class="status-label">Cache Hit Rate</div>
            <div class="status-value" id="cacheHitRate">0%</div>
          </div>
          <div class="status-item">
            <div class="status-label">Queue Length</div>
            <div class="status-value" id="queueLength">0</div>
          </div>
          <div class="status-item">
            <div class="status-label">Avg Response Time</div>
            <div class="status-value" id="avgResponseTime">0ms</div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="movies" class="movies-grid">
      <div style="grid-column: 1/-1; text-align: center; color: rgba(255,255,255,0.8); font-size: 1.2rem;">
        üé¨ Search for movies to see results here...
      </div>
    </div>
    
    <div id="downloadPanel" class="download-panel">
      <h3>üìä Download Progress</h3>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="progress-text" id="progressText">0%</div>
      
      <div class="chunk-visualization">
        <h4>üß© Chunk Status</h4>
        <div style="font-size: 12px; margin-bottom: 10px;">
          üî¥ Missing | üü° Downloading | üîµ P2P | üü¢ Server
        </div>
        <div class="chunk-grid" id="chunkGrid"></div>
      </div>
      
      <div class="peer-list">
        <h4>üåê Connected Peers</h4>
        <div id="peerList">No peers connected</div>
      </div>
      
      <div id="videoPlayer"></div>
    </div>
    
    <div class="logs" id="logs"></div>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    const SERVER_URL = 'http://localhost:8080';    // Enhanced Application state with better management
    const APP = {
      socket: null,
      localId: null,
      peerConnections: new Map(),
      dataChannels: new Map(),
      receivedChunks: new Map(),
      missingChunks: new Set(),
      downloadingChunks: new Set(),
      currentMovie: null,
      totalChunks: 0,
      chunkMap: {},
      downloadActive: false,
      downloadStartTime: null,
      chunkSources: new Map(), // Track where each chunk came from
      
      // **NEW STREAMING VARIABLES**
      streamingStarted: false,
      lastStreamedChunks: 0,
      streamingUpdateInterval: null,
      
      stats: {
        totalDownloaded: 0,
        chunksFromP2P: 0,
        chunksFromServer: 0,
        downloadSpeed: 0,
        totalBytes: 0
      },// Optimized settings
      settings: {
        maxConcurrentChunks: 5,         // Reduced from 10 to prevent overwhelming server
        p2pTimeout: 90000,              // Reduced from 15000ms
        chunkRequestInterval: 1000,     // Slower chunk requests (was 500ms)
        maxPeerConnections: 6,          // Reduced from 8
        serverFallbackDelay: 15000,     // Reduced from 20000ms
        retryAttempts: 3
      },
      // Parallel streaming state
      parallelStreaming: {
        enabled: false,
        engineActive: false,
        currentStream: null,
        stats: {
          chunksProcessed: 0,
          totalChunks: 0,
          processingSpeed: 0,
          bufferHealth: 0,
          cpuUtilization: 0,
          activeWorkers: 0,
          maxWorkers: 0,
          bandwidthUsage: 0,
          cacheHitRate: 0,
          queueLength: 0,
          avgResponseTime: 0
        }
      }
    };

    // Initialize socket connection with better error handling
    function initializeSocket() {
      APP.socket = io(SERVER_URL, {
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000
      });
      
      APP.socket.on('connect', () => {
        APP.localId = APP.socket.id;
        log('üöÄ Connected to signaling server', 'success');
        updateConnectionStatus();
      });
      
      APP.socket.on('disconnect', (reason) => {
        log(`üîå Disconnected: ${reason}`, 'warning');
        updateConnectionStatus();
      });
      
      APP.socket.on('reconnect', () => {
        log('üîÑ Reconnected to server', 'info');
        updateConnectionStatus();
      });
        APP.socket.on('signal', handleSignal);
      APP.socket.on('peersFound', handlePeersFound);
      
      // Parallel streaming event handlers
      APP.socket.on('parallelStreamStarted', handleParallelStreamStarted);
      APP.socket.on('parallelStreamError', handleParallelStreamError);
      APP.socket.on('streamingProgressUpdate', handleStreamingProgressUpdate);
      APP.socket.on('streamChunk', handleStreamChunk);
      APP.socket.on('streamError', handleStreamError);
      APP.socket.on('streamingStats', handleStreamingStats);
    }

    // Enhanced WebRTC signaling with better error handling
    async function handleSignal(data) {
      const { from, signal } = data;
      
      if (from === APP.localId) return;
      
      try {
        if (!APP.peerConnections.has(from)) {
          await createPeerConnection(from);
        }
        
        const pc = APP.peerConnections.get(from);
        
        if (signal.type === 'offer') {
          await pc.setRemoteDescription(signal);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          APP.socket.emit('signal', { to: from, from: APP.localId, signal: answer });
          log(`üì§ Sent answer to ${from.substring(0, 8)}`, 'p2p');
        } else if (signal.type === 'answer') {
          await pc.setRemoteDescription(signal);
          log(`üì• Received answer from ${from.substring(0, 8)}`, 'p2p');
        } else if (signal.candidate) {
          await pc.addIceCandidate(signal);
        }
      } catch (err) {
        log(`‚ùå Signal error with ${from.substring(0, 8)}: ${err.message}`, 'error');
        // Clean up failed connection
        APP.peerConnections.delete(from);
        APP.dataChannels.delete(from);
        updateConnectionStatus();
      }
    }

    // Enhanced peer connection creation
    async function createPeerConnection(peerId) {
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });
      
      APP.peerConnections.set(peerId, pc);
      
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          APP.socket.emit('signal', {
            to: peerId,
            from: APP.localId,
            signal: event.candidate
          });
        }
      };
      
      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        log(`üîó Connection with ${peerId.substring(0, 8)}: ${state}`, 'info');
        
        if (state === 'failed' || state === 'disconnected' || state === 'closed') {
          // Clean up failed connection
          APP.peerConnections.delete(peerId);
          APP.dataChannels.delete(peerId);
          log(`üßπ Cleaned up connection with ${peerId.substring(0, 8)}`, 'warning');
        }
        
        updateConnectionStatus();
        updatePeerList();
      };
      
      pc.ondatachannel = (event) => {
        const channel = event.channel;
        APP.dataChannels.set(peerId, channel);
        setupDataChannel(channel, peerId);
      };
      
      return pc;
    }

    // Enhanced data channel setup
    function setupDataChannel(channel, peerId) {
      channel.binaryType = 'arraybuffer';
      
      channel.onopen = () => {
        log(`‚úÖ P2P channel opened with ${peerId.substring(0, 8)}`, 'success');
        updateConnectionStatus();
        updatePeerList();
      };
      
      channel.onmessage = (event) => {
        handleDataChannelMessage(event.data, peerId);
      };
      
      channel.onclose = () => {
        log(`üîå P2P channel closed with ${peerId.substring(0, 8)}`, 'warning');
        APP.dataChannels.delete(peerId);
        updateConnectionStatus();
        updatePeerList();
      };
      
      channel.onerror = (error) => {
        log(`‚ùå P2P channel error with ${peerId.substring(0, 8)}: ${error}`, 'error');
      };
    }

    // Enhanced message handling
    function handleDataChannelMessage(data, peerId) {
      try {
        if (typeof data === 'string') {
          const message = JSON.parse(data);
          handleControlMessage(message, peerId);
        } else {
          // Binary chunk data
          handleBinaryChunk(data, peerId);
        }
      } catch (err) {
        log(`‚ùå Message error from ${peerId.substring(0, 8)}: ${err.message}`, 'error');
      }
    }

    // Control message handling
    function handleControlMessage(message, peerId) {
      switch (message.type) {
        case 'chunkRequest':
          sendChunkToPeer(message.chunkIndex, peerId);
          break;
        case 'chunkNotAvailable':
          handleChunkNotAvailable(message.chunkIndex, peerId);
          break;
      }
    }

    // Handle binary chunk data
    function handleBinaryChunk(data, peerId) {
      try {
        const view = new DataView(data);
        const chunkIndex = view.getUint32(0);
        const chunkData = new Uint8Array(data.slice(4));
        
        receiveChunk(chunkIndex, chunkData, 'p2p', peerId);
        log(`üì• Received chunk ${chunkIndex} from peer ${peerId.substring(0, 8)} (${formatBytes(chunkData.length)})`, 'success');
      } catch (err) {
        log(`‚ùå Error processing chunk from ${peerId.substring(0, 8)}: ${err.message}`, 'error');
      }
    }

    // Enhanced chunk sending
    function sendChunkToPeer(chunkIndex, peerId) {
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      if (movieChunks && movieChunks.has(chunkIndex)) {
        const chunkData = movieChunks.get(chunkIndex);
        const channel = APP.dataChannels.get(peerId);
        
        if (channel && channel.readyState === 'open') {
          try {
            // Send as binary with chunk index header
            const buffer = new ArrayBuffer(4 + chunkData.length);
            const view = new DataView(buffer);
            view.setUint32(0, chunkIndex);
            new Uint8Array(buffer, 4).set(chunkData);
            
            channel.send(buffer);
            log(`üì§ Sent chunk ${chunkIndex} to peer ${peerId.substring(0, 8)} (${formatBytes(chunkData.length)})`, 'p2p');
          } catch (err) {
            log(`‚ùå Failed to send chunk ${chunkIndex} to ${peerId.substring(0, 8)}: ${err.message}`, 'error');
          }
        }
      } else {
        // Send "not available" message
        const channel = APP.dataChannels.get(peerId);
        if (channel && channel.readyState === 'open') {
          channel.send(JSON.stringify({
            type: 'chunkNotAvailable',
            chunkIndex: chunkIndex
          }));
        }
      }
    }

    // Handle when peer doesn't have chunk
    function handleChunkNotAvailable(chunkIndex, peerId) {
      const chunkKey = `${APP.currentMovie}_${chunkIndex}`;
      log(`‚ö†Ô∏è Peer ${peerId.substring(0, 8)} doesn't have chunk ${chunkIndex}`, 'warning');
      
      // Try next peer or fallback to server
      if (APP.downloadingChunks.has(chunkKey)) {
        setTimeout(() => {
          if (APP.downloadingChunks.has(chunkKey)) {
            downloadChunkFromServer(chunkIndex, chunkKey);
          }
        }, 1000);
      }
    }    // Enhanced chunk receiving with real-time streaming
    function receiveChunk(chunkIndex, chunkData, source, peerId = null) {
      if (!APP.receivedChunks.has(APP.currentMovie)) {
        APP.receivedChunks.set(APP.currentMovie, new Map());
      }
      
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      movieChunks.set(chunkIndex, chunkData);
      
      const chunkKey = `${APP.currentMovie}_${chunkIndex}`;
      APP.missingChunks.delete(chunkKey);
      APP.downloadingChunks.delete(chunkKey);
      
      // Track source
      APP.chunkSources.set(chunkKey, source);
      
      // Update stats
      if (source === 'p2p') {
        APP.stats.chunksFromP2P++;
      } else {
        APP.stats.chunksFromServer++;
      }
      
      APP.stats.totalDownloaded += chunkData.length;
      APP.stats.totalBytes += chunkData.length;
      
      // Register chunk with tracker
      APP.socket.emit('registerChunk', { 
        movie: APP.currentMovie, 
        chunkIndex 
      });
      
      updateProgress();
      updateChunkVisualization();
      updateDownloadSpeed();
      
      // **REAL-TIME STREAMING**: Start playing if we have enough consecutive chunks
      checkStreamingReadiness();
      
      // Check if download should complete (allow some missing chunks)
      if (shouldCompleteDownload()) {
        completeDownload();
      }
    }    // **ENHANCED**: Check if we can start streaming with REAL torrent chunks
    function checkStreamingReadiness() {
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      if (!movieChunks || movieChunks.size < 3) return; // Need at least 3 chunks
      
      // Check if we have the first few consecutive chunks for streaming
      let consecutiveFromStart = 0;
      for (let i = 0; i < Math.min(10, APP.totalChunks); i++) { // Check first 10 chunks
        if (movieChunks.has(i)) {
          consecutiveFromStart++;
        } else {
          break;
        }
      }
      
      // If we have at least 3 consecutive chunks from the start, enable REAL streaming
      if (consecutiveFromStart >= 3 && !APP.streamingStarted) {
        APP.streamingStarted = true;
        log(`üé¨ Starting REAL video streaming with ${consecutiveFromStart} consecutive chunks ready!`, 'success');
        startRealTimeStreaming();
      }
    }// **ENHANCED**: Start real-time streaming with REAL video chunks
    function startRealTimeStreaming() {
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      const availableChunks = [];
      
      // Get all consecutive chunks from the beginning (required for proper MP4 streaming)
      for (let i = 0; i < APP.totalChunks; i++) {
        if (movieChunks.has(i)) {
          availableChunks.push(movieChunks.get(i));
        } else {
          break; // Stop at first missing chunk to maintain video integrity
        }
      }
      
      if (availableChunks.length > 0) {
        try {
          // Create proper MP4 blob for streaming REAL video content
          const partialBlob = new Blob(availableChunks, { type: 'video/mp4' });
          const streamUrl = URL.createObjectURL(partialBlob);
          
          // Calculate approximate playable duration
          const estimatedDuration = (availableChunks.length / APP.totalChunks) * 120; // Assume ~2hr movie
          
          document.getElementById('videoPlayer').innerHTML = `
            <h4>üé¨ LIVE STREAMING - Real Torrent Video (${availableChunks.length}/${APP.totalChunks} chunks)</h4>
            <video controls autoplay muted style="max-width: 100%; margin: 20px 0;" preload="metadata" id="liveVideo">
              <source src="${streamUrl}" type="video/mp4">
              Your browser does not support video playback.
            </video>
            <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #28a745;">
              <strong>üî¥ LIVE STREAMING ACTIVE:</strong> Playing real video chunks from P2P network<br>
              üìä Buffer: ~${estimatedDuration.toFixed(1)} minutes available<br>
              üåê Sources: ${APP.stats.chunksFromP2P} P2P + ${APP.stats.chunksFromServer} server chunks<br>
              <small>Video extends automatically as peers share more real chunks</small>
            </div>
          `;
          
          // Enhanced streaming with better update frequency for REAL video
          APP.streamingUpdateInterval = setInterval(updateStreamingBlob, 1500);
          
          log(`üé¨ Started REAL video streaming with ${availableChunks.length} consecutive chunks`, 'success');
          
        } catch (err) {
          log(`‚ùå Error starting real-time streaming: ${err.message}`, 'error');
        }
      }
    }    // **ENHANCED**: Update streaming blob with new real chunks as they arrive
    function updateStreamingBlob() {
      if (!APP.streamingStarted || !APP.currentMovie) return;
      
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      const availableChunks = [];
      
      // Get all consecutive chunks for REAL video playback
      for (let i = 0; i < APP.totalChunks; i++) {
        if (movieChunks.has(i)) {
          availableChunks.push(movieChunks.get(i));
        } else {
          break; // Stop at first missing chunk to maintain video integrity
        }
      }
      
      // Update video if we have more REAL chunks
      if (availableChunks.length > APP.lastStreamedChunks) {
        APP.lastStreamedChunks = availableChunks.length;
        
        try {
          // Create updated blob with more REAL video chunks
          const updatedBlob = new Blob(availableChunks, { type: 'video/mp4' });
          const newUrl = URL.createObjectURL(updatedBlob);
          
          const videoElement = document.querySelector('#videoPlayer video');
          if (videoElement) {
            const currentTime = videoElement.currentTime;
            const wasPlaying = !videoElement.paused;
            
            // Save playback state
            videoElement.src = newUrl;
            videoElement.load();
            
            // Restore playback position and state
            videoElement.currentTime = currentTime;
            if (wasPlaying) {
              videoElement.play().catch(err => {
                log(`‚ö†Ô∏è Autoplay blocked, user interaction required`, 'warning');
              });
            }
            
            // Update streaming status with REAL chunk info
            const estimatedDuration = (availableChunks.length / APP.totalChunks) * 120;
            document.querySelector('#videoPlayer h4').textContent = 
              `üé¨ LIVE STREAMING - Real Torrent Video (${availableChunks.length}/${APP.totalChunks} chunks)`;
            
            // Update buffer info
            const bufferInfo = document.querySelector('#videoPlayer div');
            if (bufferInfo) {
              bufferInfo.innerHTML = `
                <strong>üî¥ LIVE STREAMING ACTIVE:</strong> Playing real video chunks from P2P network<br>
                üìä Buffer: ~${estimatedDuration.toFixed(1)} minutes available<br>
                üåê Sources: ${APP.stats.chunksFromP2P} P2P + ${APP.stats.chunksFromServer} server chunks<br>
                <small>Video extends automatically as peers share more real chunks</small>
              `;
            }
            
            log(`üé¨ Updated stream with ${availableChunks.length} REAL chunks (~${estimatedDuration.toFixed(1)}min)`, 'success');
          }
        } catch (err) {
          log(`‚ùå Error updating REAL stream: ${err.message}`, 'error');
        }
      }
    }

    // Smart download completion detection
    function shouldCompleteDownload() {
      if (APP.missingChunks.size === 0) {
        return true; // All chunks received
      }
      
      // Check if we've been stuck for too long
      const stuckThreshold = 60000; // 1 minute
      const now = Date.now();
      
      // Count recently failed chunks
      const recentlyFailedChunks = Array.from(APP.missingChunks).filter(chunkKey => {
        return localStorage.getItem(`failed_${chunkKey}`) === 'true';
      });
      
      // Complete if most chunks are downloaded and remaining are permanently failed
      const receivedChunks = APP.receivedChunks.get(APP.currentMovie)?.size || 0;
      const completionThreshold = Math.floor(APP.totalChunks * 0.85); // 85% threshold
      
      if (receivedChunks >= completionThreshold && recentlyFailedChunks.length > 0) {
        log(`üéØ Completing download with ${receivedChunks}/${APP.totalChunks} chunks (${(receivedChunks/APP.totalChunks*100).toFixed(1)}%)`, 'info');
        return true;
      }
      
      return false;
    }

    // Enhanced peers found handler
    async function handlePeersFound(data) {
      const { movie, peers, chunkMap } = data;
      APP.chunkMap = chunkMap;
      
      log(`üîç Found ${peers.length} peers for ${movie}`, 'info');
      
      // Limit peer connections
      const maxPeers = Math.min(peers.length, APP.settings.maxPeerConnections);
      const selectedPeers = peers.slice(0, maxPeers);
      
      // Connect to peers
      for (const peerId of selectedPeers) {
        if (peerId !== APP.localId && !APP.peerConnections.has(peerId)) {
          try {
            const pc = await createPeerConnection(peerId);
            const channel = pc.createDataChannel('chunks', {
              ordered: false,
              maxRetransmits: 0
            });
            APP.dataChannels.set(peerId, channel);
            setupDataChannel(channel, peerId);
            
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            APP.socket.emit('signal', {
              to: peerId,
              from: APP.localId,
              signal: offer
            });
            
            log(`üì§ Sent offer to peer ${peerId.substring(0, 8)}`, 'p2p');
          } catch (err) {
            log(`‚ùå Failed to connect to peer ${peerId.substring(0, 8)}: ${err.message}`, 'error');
          }
        }
      }
      
      // Start requesting chunks after peer connections
      setTimeout(startChunkRequests, 2000);
    }    // Enhanced chunk requesting system with streaming priority
    function startChunkRequests() {
      if (!APP.downloadActive) return;
      
      const requestChunks = () => {
        if (!APP.downloadActive || APP.missingChunks.size === 0) return;
        
        const missingArray = Array.from(APP.missingChunks);
        
        // **ENHANCED**: Prioritize first chunks for streaming
        const sortedChunks = missingArray.sort((a, b) => {
          const indexA = parseInt(a.split('_')[1]);
          const indexB = parseInt(b.split('_')[1]);
          
          // Prioritize first 10 chunks for streaming
          const priorityA = indexA < 10 ? indexA : indexA + 1000;
          const priorityB = indexB < 10 ? indexB : indexB + 1000;
          
          return priorityA - priorityB;
        });
        
        const batchSize = Math.min(APP.settings.maxConcurrentChunks, sortedChunks.length);
        
        for (let i = 0; i < batchSize; i++) {
          const chunkKey = sortedChunks[i];
          if (APP.downloadingChunks.has(chunkKey)) continue;
          
          const chunkIndex = parseInt(chunkKey.split('_')[1]);
          requestChunkOptimized(chunkIndex, chunkKey);
        }
        
        if (APP.missingChunks.size > 0) {
          setTimeout(requestChunks, APP.settings.chunkRequestInterval);
        }
      };
      
      requestChunks();
    }

    // Optimized chunk request with better P2P priority
    function requestChunkOptimized(chunkIndex, chunkKey) {
      APP.downloadingChunks.add(chunkKey);
      
      // Try P2P first with proper priority
      let p2pRequested = false;
      const peersWithChunk = APP.chunkMap[chunkIndex] || [];
      
      for (const peerId of peersWithChunk) {
        const channel = APP.dataChannels.get(peerId);
        if (channel && channel.readyState === 'open') {
          channel.send(JSON.stringify({
            type: 'chunkRequest',
            chunkIndex: chunkIndex
          }));
          p2pRequested = true;
          log(`üì§ Requested chunk ${chunkIndex} from peer ${peerId.substring(0, 8)}`, 'p2p');
          break;
        }
      }
      
      // Server fallback only after significant delay
      if (!p2pRequested) {
        // No P2P peers available, try server immediately
        downloadChunkFromServer(chunkIndex, chunkKey);
      } else {
        // P2P requested, set server fallback with delay
        setTimeout(() => {
          if (APP.downloadingChunks.has(chunkKey)) {
            log(`‚è∞ P2P timeout for chunk ${chunkIndex}, trying server`, 'warning');
            downloadChunkFromServer(chunkIndex, chunkKey);
          }
        }, APP.settings.p2pTimeout);
      }
    }    // Enhanced server download with better error handling
    async function downloadChunkFromServer(chunkIndex, chunkKey) {
      try {
        log(`üåê Downloading chunk ${chunkIndex} from server`, 'info');
        
        const response = await fetch(
          `${SERVER_URL}/download_chunk?movie=${encodeURIComponent(APP.currentMovie)}&chunkIndex=${chunkIndex}`,
          { 
            signal: AbortSignal.timeout(45000), // 45 second timeout
            headers: { 'Cache-Control': 'no-cache' }
          }
        );
        
        if (response.ok) {
          const arrayBuffer = await response.arrayBuffer();
          const chunkData = new Uint8Array(arrayBuffer);
          receiveChunk(chunkIndex, chunkData, 'server');
          log(`‚úÖ Downloaded chunk ${chunkIndex} from server (${formatBytes(chunkData.length)})`, 'success');
        } else {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(`Server returned ${response.status}: ${errorData.error || response.statusText}`);
        }
      } catch (err) {
        log(`‚ùå Server download failed for chunk ${chunkIndex}: ${err.message}`, 'error');
        APP.downloadingChunks.delete(chunkKey);
        
        // Enhanced retry mechanism with exponential backoff
        let retryCount = parseInt(localStorage.getItem(`retry_${chunkKey}`) || '0');
        if (retryCount < APP.settings.retryAttempts) {
          retryCount++;
          localStorage.setItem(`retry_${chunkKey}`, retryCount.toString());
          
          // Exponential backoff: 3s, 6s, 12s
          const backoffDelay = 3000 * Math.pow(2, retryCount - 1);
          
          setTimeout(() => {
            if (APP.downloadingChunks.has(chunkKey)) return; // Already downloading
            if (!APP.downloadActive) return; // Download stopped
            
            APP.missingChunks.add(chunkKey);
            log(`üîÑ Retrying chunk ${chunkIndex} (attempt ${retryCount}/${APP.settings.retryAttempts})`, 'info');
          }, backoffDelay);
        } else {
          log(`‚ùå Gave up on chunk ${chunkIndex} after ${retryCount} attempts`, 'error');
          // Mark as permanently failed to avoid infinite retries
          localStorage.setItem(`failed_${chunkKey}`, 'true');
        }
      }
    }    // Enhanced download start
    async function startDownload(movie) {
      if (APP.downloadActive) {
        log('‚ö†Ô∏è Download already in progress', 'warning');
        return;
      }
      
      APP.downloadActive = true;
      APP.currentMovie = movie.title;
      APP.downloadStartTime = Date.now();
      
      // Initialize totalChunks with safe default FIRST
      APP.totalChunks = 100; // Safe default to prevent NaN errors
      
      log(`üöÄ Starting optimized download: ${movie.title}`, 'info');
        // Store magnet link for BOTH trackers
      if (movie.magnet_link) {
        try {
          // Store for main tracker
          await fetch(`${SERVER_URL}/store_magnet`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              movie: movie.title,
              magnetLink: movie.magnet_link
            })
          });
          
          // Store for parallel tracker too
          await fetch(`${SERVER_URL}/parallel/store_magnet`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              movie: movie.title,
              magnetLink: movie.magnet_link
            })
          });
          
          log(`üíæ Stored magnet link for ${movie.title} in both trackers`, 'info');
        } catch (err) {
          log(`‚ö†Ô∏è Failed to store magnet link: ${err.message}`, 'warning');
        }
      } else {
        log(`‚ö†Ô∏è No magnet link available for ${movie.title}`, 'warning');
      }
      
      // Get movie info dynamically
      try {
        const response = await fetch(`${SERVER_URL}/get_movie_info?movie=${encodeURIComponent(movie.title)}`);
        const movieInfo = await response.json();
        const calculatedChunks = movieInfo.totalChunks || Math.ceil((movieInfo.fileSize || 100 * 1024 * 1024) / (1024 * 1024));
        
        // Only update if we get a valid number
        if (calculatedChunks && calculatedChunks > 0) {
          APP.totalChunks = calculatedChunks;
        }
        
        log(`üìä Movie info: ${APP.totalChunks} chunks (${formatBytes(movieInfo.fileSize || 0)})`, 'info');
      } catch (err) {
        log(`‚ùå Failed to get movie info: ${err.message}`, 'error');
        // Keep the safe default (100 chunks)
        log(`üìä Using default ${APP.totalChunks} chunks`, 'info');
      }
      
      // Initialize missing chunks
      APP.missingChunks.clear();
      APP.downloadingChunks.clear();
      APP.chunkSources.clear();
      for (let i = 0; i < APP.totalChunks; i++) {
        APP.missingChunks.add(`${movie.title}_${i}`);
      }
      
      // Reset stats
      APP.stats = {
        totalDownloaded: 0,
        chunksFromP2P: 0,
        chunksFromServer: 0,
        downloadSpeed: 0,
        totalBytes: 0
      };
      
      // Show download panel
      document.getElementById('downloadPanel').style.display = 'block';
      updateProgress();
      updateChunkVisualization();
      
      // Find peers
      APP.socket.emit('findPeers', { movie: movie.title });
      
      log(`üîç Looking for peers and starting download...`, 'info');
    }// Enhanced download completion
    function completeDownload() {
      const downloadTime = (Date.now() - APP.downloadStartTime) / 1000;
      const avgSpeed = APP.stats.totalBytes / downloadTime / 1024; // KB/s
      
      log(`üéâ Download complete in ${downloadTime.toFixed(1)}s!`, 'success');
      log(`üìä P2P: ${APP.stats.chunksFromP2P} chunks | Server: ${APP.stats.chunksFromServer} chunks`, 'info');
      log(`‚ö° Average speed: ${avgSpeed.toFixed(1)} KB/s`, 'info');
      
      APP.downloadActive = false;
      
      // **CLEANUP STREAMING**
      if (APP.streamingUpdateInterval) {
        clearInterval(APP.streamingUpdateInterval);
        APP.streamingUpdateInterval = null;
      }
      APP.streamingStarted = false;
      APP.lastStreamedChunks = 0;
      
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      const chunks = [];
      
      for (let i = 0; i < APP.totalChunks; i++) {
        if (movieChunks.has(i)) {
          chunks.push(movieChunks.get(i));
        } else {
          log(`‚ö†Ô∏è Missing chunk ${i}, using empty chunk`, 'warning');
          chunks.push(new Uint8Array(1024 * 1024)); // 1MB empty chunk
        }
      }
      
      try {
        // Create final complete video blob
        const blob = new Blob(chunks, { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);
        
        const p2pEfficiency = ((APP.stats.chunksFromP2P / APP.totalChunks) * 100).toFixed(1);
        
        document.getElementById('videoPlayer').innerHTML = `
          <h4>üé¨ Download Complete!</h4>
          <video controls style="max-width: 100%; margin: 20px 0;" preload="metadata">
            <source src="${url}" type="video/mp4">
            Your browser does not support video playback.
          </video>
          <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            <strong>üìä Download Statistics:</strong><br>
            üîµ P2P Chunks: ${APP.stats.chunksFromP2P} (${p2pEfficiency}%)<br>
            üü¢ Server Chunks: ${APP.stats.chunksFromServer}<br>
            ‚ö° Average Speed: ${avgSpeed.toFixed(1)} KB/s<br>
            ‚è±Ô∏è Total Time: ${downloadTime.toFixed(1)}s<br>
            üé¨ <strong>Real-time streaming was ${APP.streamingStarted ? 'enabled' : 'disabled'}</strong>
          </div>
          <a href="${url}" download="${APP.currentMovie}.mp4" 
             style="display: inline-block; padding: 12px 24px; background: #007bff; color: white; text-decoration: none; border-radius: 8px; margin: 5px;">
            üì• Download File
          </a>
          <button onclick="startNewDownload()" 
             style="display: inline-block; padding: 12px 24px; background: #28a745; color: white; border: none; border-radius: 8px; margin: 5px; cursor: pointer;">
            üöÄ Start New Download
          </button>
        `;
      } catch (err) {
        log(`‚ùå Error creating video: ${err.message}`, 'error');
      }
      
      updateProgress();
      updateChunkVisualization();
    }

    // Start new download function
    function startNewDownload() {
      document.getElementById('downloadPanel').style.display = 'none';
      document.getElementById('videoPlayer').innerHTML = '';
      APP.currentMovie = null;
      APP.downloadActive = false;
      updateConnectionStatus();
    }    // Enhanced progress update
    function updateProgress() {
      if (!APP.currentMovie) return;
      
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      const received = movieChunks ? movieChunks.size : 0;
      
      // Ensure totalChunks is valid
      if (!APP.totalChunks || APP.totalChunks === 0) {
        APP.totalChunks = 100; // Default fallback
      }
      
      const progress = (received / APP.totalChunks) * 100;
      const totalBytes = APP.stats.totalBytes || 0;
      
      // Safe progress display
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      const downloadProgress = document.getElementById('downloadProgress');
      
      if (progressFill) {
        progressFill.style.width = `${Math.min(progress, 100)}%`;
      }
      
      if (progressText) {
        progressText.textContent = 
          `${progress.toFixed(1)}% (${received}/${APP.totalChunks} chunks)`;
      }
      
      if (downloadProgress) {
        downloadProgress.textContent = `${progress.toFixed(1)}%`;
      }
      
      // Update P2P efficiency with safe calculation
      const totalChunksDownloaded = APP.stats.chunksFromP2P + APP.stats.chunksFromServer;
      const p2pEfficiency = totalChunksDownloaded > 0 ? 
        (APP.stats.chunksFromP2P / totalChunksDownloaded) * 100 : 0;
      
      const p2pEfficiencyEl = document.getElementById('p2pEfficiency');
      if (p2pEfficiencyEl) {
        p2pEfficiencyEl.textContent = `${p2pEfficiency.toFixed(1)}%`;
      }
        // Log progress safely with streaming status
      if (received > 0) {
        const streamingStatus = APP.streamingStarted ? 'üé¨ STREAMING' : 'üì• DOWNLOADING';
        log(`üìä ${streamingStatus} ${APP.currentMovie}: ${progress.toFixed(1)}% (${formatBytes(totalBytes)})`, 'info');
      }
    }

    // Update chunk visualization
    function updateChunkVisualization() {
      if (!APP.currentMovie || APP.totalChunks === 0) return;
      
      const chunkGrid = document.getElementById('chunkGrid');
      chunkGrid.innerHTML = '';
      
      const movieChunks = APP.receivedChunks.get(APP.currentMovie);
      
      for (let i = 0; i < APP.totalChunks; i++) {
        const chunkDiv = document.createElement('div');
        chunkDiv.className = 'chunk-item';
        chunkDiv.textContent = i;
        
        const chunkKey = `${APP.currentMovie}_${i}`;
        
        if (movieChunks && movieChunks.has(i)) {
          const source = APP.chunkSources.get(chunkKey);
          if (source === 'p2p') {
            chunkDiv.classList.add('chunk-p2p');
            chunkDiv.title = `Chunk ${i} - Downloaded via P2P`;
          } else {
            chunkDiv.classList.add('chunk-server');
            chunkDiv.title = `Chunk ${i} - Downloaded from server`;
          }
        } else if (APP.downloadingChunks.has(chunkKey)) {
          chunkDiv.classList.add('chunk-downloading');
          chunkDiv.title = `Chunk ${i} - Currently downloading`;
        } else {
          chunkDiv.classList.add('chunk-missing');
          chunkDiv.title = `Chunk ${i} - Not downloaded`;
        }
        
        chunkGrid.appendChild(chunkDiv);
      }
    }

    // Update peer list
    function updatePeerList() {
      const peerList = document.getElementById('peerList');
      
      if (APP.dataChannels.size === 0) {
        peerList.innerHTML = 'No peers connected';
        return;
      }
      
      peerList.innerHTML = '';
      
      for (const [peerId, channel] of APP.dataChannels) {
        const peerDiv = document.createElement('div');
        peerDiv.className = 'peer-item';
        
        const state = channel.readyState;
        const stateColor = state === 'open' ? '#28a745' : '#dc3545';
        
        peerDiv.innerHTML = `
          <span>Peer: ${peerId.substring(0, 8)}...</span>
          <span style="color: ${stateColor}; font-weight: bold;">${state}</span>
        `;
        
        peerList.appendChild(peerDiv);
      }
    }    // Update download speed
    function updateDownloadSpeed() {
      if (!APP.downloadStartTime) return;
      
      const elapsed = (Date.now() - APP.downloadStartTime) / 1000;
      const totalBytes = APP.stats.totalBytes || 0;
      const speed = elapsed > 0 ? (totalBytes / elapsed / 1024) : 0;
      
      APP.stats.downloadSpeed = speed;
      const downloadSpeedEl = document.getElementById('downloadSpeed');
      if (downloadSpeedEl) {
        downloadSpeedEl.textContent = `${speed.toFixed(1)} KB/s`;
      }
    }

    // Enhanced connection status update
    function updateConnectionStatus() {
      document.getElementById('connectionStatus').textContent = 
        APP.socket?.connected ? 'üü¢ Connected' : 'üî¥ Disconnected';
      document.getElementById('peerId').textContent = 
        APP.localId ? APP.localId.substring(0, 8) + '...' : 'Not Connected';
      document.getElementById('activePeers').textContent = 
        Array.from(APP.dataChannels.values()).filter(ch => ch.readyState === 'open').length;
    }

    // Search movies (unchanged)
    async function searchMovies(query) {
      try {
        const response = await fetch(`${SERVER_URL}/search?query=${encodeURIComponent(query)}`);
        const movies = await response.json();
        displayMovies(movies);
        log(`‚úÖ Found ${movies.length} movies`, 'success');
      } catch (err) {
        log(`‚ùå Search failed: ${err.message}`, 'error');
      }
    }

    // Display movies (unchanged)
    function displayMovies(movies) {
      const container = document.getElementById('movies');
      container.innerHTML = '';
      
      if (!movies || movies.length === 0) {
        container.innerHTML = `
          <div style="grid-column: 1/-1; text-align: center; color: rgba(255,255,255,0.8);">
            üòî No movies found
          </div>
        `;
        return;
      }
      
      movies.forEach(movie => {
        const movieCard = document.createElement('div');
        movieCard.className = 'movie-card';        movieCard.innerHTML = `
          <img src="${movie.medium_cover_image}" alt="${movie.title}" />
          <div class="movie-info">
            <div class="movie-title">${movie.title}</div>
            <div class="movie-year">${movie.year}</div>
            <div class="movie-summary">${movie.summary || 'No description available.'}</div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button class="download-btn" onclick="startDownload(${JSON.stringify(movie).replace(/"/g, '&quot;')})">
                üåê P2P Download
              </button>
              <button class="download-btn" onclick="startDownloadWithParallelStreaming('${movie.title.replace(/'/g, "\\'")}', '${(movie.magnet_link || '').replace(/'/g, "\\'")}')" 
                      style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);" 
                      ${!movie.magnet_link ? 'disabled title="No magnet link available"' : ''}>
                üöÄ Parallel Stream ${!movie.magnet_link ? '(No Magnet)' : ''}
              </button>
            </div>
            ${!movie.magnet_link ? '<div style="color: #ff6b6b; font-size: 12px; margin-top: 5px;">‚ö†Ô∏è Magnet link not available for this movie</div>' : ''}
          </div>
        `;
        
        container.appendChild(movieCard);
      });
    }

    // Enhanced logging system
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry log-${type}`;
      logEntry.textContent = `[${timestamp}] ${message}`;
      
      const logsContainer = document.getElementById('logs');
      logsContainer.appendChild(logEntry);
      logsContainer.scrollTop = logsContainer.scrollHeight;
      
      // Limit log entries
      while (logsContainer.children.length > 200) {
        logsContainer.removeChild(logsContainer.firstChild);
      }
      
      console.log(`[${type.toUpperCase()}] ${message}`);
    }    // Utility function to format bytes
    function formatBytes(bytes) {
      if (!bytes || bytes === 0 || isNaN(bytes)) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // PARALLEL STREAMING FUNCTIONS
    
    // Handle parallel stream started
    function handleParallelStreamStarted(data) {
      const { movie, engineId, stats } = data;
      log(`üöÄ Parallel streaming started for ${movie}`, 'success');
      
      APP.parallelStreaming.enabled = true;
      APP.parallelStreaming.engineActive = true;
      APP.parallelStreaming.currentStream = movie;
      
      document.getElementById('parallelStreamingPanel').style.display = 'block';
      updateParallelStreamingUI();
    }

    // Handle parallel stream error
    function handleParallelStreamError(data) {
      const { movie, error } = data;
      log(`‚ùå Parallel streaming error for ${movie}: ${error}`, 'error');
      APP.parallelStreaming.engineActive = false;
      updateParallelStreamingUI();
    }

    // Handle streaming progress updates
    function handleStreamingProgressUpdate(data) {
      const { movie, stats } = data;
      if (movie === APP.parallelStreaming.currentStream) {
        APP.parallelStreaming.stats = { ...APP.parallelStreaming.stats, ...stats };
        updateParallelStreamingUI();
        
        // Also update regular progress
        updateProgress();
        updateChunkVisualization();
      }
    }

    // Handle stream chunk data
    function handleStreamChunk(data) {
      const { movie, chunk, timestamp } = data;
      // Process incoming chunk data for real-time streaming
      log(`üì¶ Received stream chunk for ${movie} (${formatBytes(chunk.byteLength)})`, 'info');
    }

    // Handle stream error
    function handleStreamError(data) {
      const { movie, error } = data;
      log(`‚ùå Stream error for ${movie}: ${error}`, 'error');
    }

    // Handle streaming statistics
    function handleStreamingStats(data) {
      const { movie, stats } = data;
      if (movie === APP.parallelStreaming.currentStream) {
        APP.parallelStreaming.stats = { ...APP.parallelStreaming.stats, ...stats };
        updateParallelStreamingUI();
      }
    }

    // Start parallel streaming for a movie
    function startParallelStreaming(movie, magnetLink) {
      if (!APP.socket) {
        log('‚ùå Socket not connected', 'error');
        return;
      }

      log(`üöÄ Starting parallel streaming for ${movie}`, 'info');
      APP.socket.emit('startParallelStream', { movie, magnetLink });
    }    // Update parallel streaming UI
    function updateParallelStreamingUI() {
      const stats = APP.parallelStreaming.stats || {};
      
      // Update status indicators
      const streamingStatus = document.getElementById('streamingStatus');
      if (streamingStatus) {
        streamingStatus.textContent = APP.parallelStreaming.engineActive ? 'Active' : 'Idle';
      }
      
      const chunksProcessed = document.getElementById('chunksProcessed');
      if (chunksProcessed) {
        chunksProcessed.textContent = `${stats.chunksProcessed || 0}/${stats.totalChunks || APP.totalChunks}`;
      }
      
      const bufferHealth = document.getElementById('bufferHealth');
      if (bufferHealth) {
        bufferHealth.textContent = `${(stats.bufferHealth || 0).toFixed(1)}%`;
      }
      
      const processingSpeed = document.getElementById('processingSpeed');
      if (processingSpeed) {
        processingSpeed.textContent = `${(stats.processingSpeed || 0).toFixed(1)} chunks/s`;
      }
      
      const cpuUtilization = document.getElementById('cpuUtilization');
      if (cpuUtilization) {
        cpuUtilization.textContent = `${(stats.cpuUtilization || 0).toFixed(1)}%`;
      }
      
      const activeWorkers = document.getElementById('activeWorkers');
      if (activeWorkers) {
        activeWorkers.textContent = `${stats.activeWorkers || 0}/${stats.maxWorkers || 0}`;
      }
      
      // Update performance metrics
      const bandwidthUsage = document.getElementById('bandwidthUsage');
      if (bandwidthUsage) {
        bandwidthUsage.textContent = `${((stats.bandwidthUsage || 0) / 1000000).toFixed(1)} Mbps`;
      }
      
      const cacheHitRate = document.getElementById('cacheHitRate');
      if (cacheHitRate) {
        cacheHitRate.textContent = `${(stats.cacheHitRate || 0).toFixed(1)}%`;
      }
      
      const queueLength = document.getElementById('queueLength');
      if (queueLength) {
        queueLength.textContent = stats.queueLength || 0;
      }
      
      const avgResponseTime = document.getElementById('avgResponseTime');
      if (avgResponseTime) {
        avgResponseTime.textContent = `${(stats.avgResponseTime || 0).toFixed(0)}ms`;
      }
    }    // Enhanced download function with parallel streaming option
    async function startDownloadWithParallelStreaming(movie, magnetLink) {
      // ‚úÖ 1. VALIDATE MAGNET LINK FIRST
      if (!magnetLink || magnetLink.trim() === '') {
        log(`‚ùå Cannot start parallel streaming: Magnet link is missing for ${movie}`, 'error');
        return;
      }
      
      log(`üöÄ Starting parallel streaming for ${movie}`, 'info');
      log(`üß≤ Using magnet link: ${magnetLink.substring(0, 50)}...`, 'info');
      
      // Initialize movie and download state
      APP.currentMovie = movie;
      APP.downloadActive = true;
      APP.downloadStartTime = Date.now();
      
      // Clear previous state
      APP.receivedChunks.set(movie, new Map());
      APP.missingChunks.clear();
      APP.downloadingChunks.clear();
      APP.chunkSources.clear();
      
      // Reset streaming state
      APP.streamingStarted = false;
      APP.lastStreamedChunks = 0;
      if (APP.streamingUpdateInterval) {
        clearInterval(APP.streamingUpdateInterval);
        APP.streamingUpdateInterval = null;
      }
      
      // ‚úÖ 2. START WITH SAFE DEFAULT BUT GET REAL SIZE FROM SERVER
      APP.totalChunks = 100; // Safe default to prevent NaN errors
      
      try {
        // ‚úÖ 3. STORE MAGNET LINK ON SERVER FIRST
        log(`üíæ Storing magnet link for ${movie}...`, 'info');
        await fetch(`${SERVER_URL}/parallel/store_magnet`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            movie: movie,
            magnetLink: magnetLink
          })
        });
        
        // ‚úÖ 4. START PARALLEL STREAMING ENGINE
        log(`üöÄ Starting parallel streaming engine...`, 'info');
        const streamResponse = await fetch(`${SERVER_URL}/parallel/start_parallel_stream`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            movie: movie,
            peerId: APP.localId || 'unknown'
          })
        });
        
        if (streamResponse.ok) {
          const streamData = await streamResponse.json();
          log(`‚úÖ Parallel streaming engine started: ${streamData.message}`, 'success');
        }
        
        // ‚úÖ 5. GET REAL MOVIE INFO FROM TORRENT
        log(`üìä Getting real movie info from torrent...`, 'info');
        const infoResponse = await fetch(`${SERVER_URL}/parallel/get_movie_info?movie=${encodeURIComponent(movie)}`);
        
        if (infoResponse.ok) {
          const movieInfo = await infoResponse.json();
          
          // ‚úÖ 6. USE REAL CHUNK COUNT FROM TORRENT
          if (movieInfo.totalChunks && movieInfo.totalChunks > 0) {
            APP.totalChunks = movieInfo.totalChunks;
            log(`üìä Real movie info: ${APP.totalChunks} chunks (${formatBytes(movieInfo.fileSize)})`, 'success');
          } else {
            log(`‚ö†Ô∏è Using default chunk count (torrent not ready yet)`, 'warning');
          }
        } else {
          log(`‚ö†Ô∏è Failed to get movie info, using default chunk count`, 'warning');
        }
        
      } catch (error) {
        log(`‚ùå Error setting up parallel streaming: ${error.message}`, 'error');
        log(`‚ö†Ô∏è Continuing with default settings...`, 'warning');
      }
      
      // Populate missing chunks with REAL count
      for (let i = 0; i < APP.totalChunks; i++) {
        APP.missingChunks.add(`${movie}_${i}`);
      }
      
      // Show UI
      document.getElementById('downloadPanel').style.display = 'block';
      document.getElementById('parallelStreamingPanel').style.display = 'block';
      
      // Update UI
      updateProgress();
      updateChunkVisualization();
      
      log(`üé¨ Parallel streaming ready: ${movie} (${APP.totalChunks} chunks)`, 'success');
      
      // Find peers and enable parallel streaming mode
      if (APP.socket) {
        APP.socket.emit('findPeers', { movie });
      }
      
      APP.parallelStreaming.enabled = true;
      APP.parallelStreaming.engineActive = true;
      APP.parallelStreaming.currentStream = movie;
      
      // Start downloading chunks using parallel tracker
      setTimeout(() => {
        startParallelChunkDownload();
      }, 3000); // Give server time to process torrent
    }

    // **NEW**: Start downloading chunks using parallel tracker
    function startParallelChunkDownload() {
      if (!APP.downloadActive || APP.missingChunks.size === 0) return;
      
      const downloadChunks = async () => {
        const missingArray = Array.from(APP.missingChunks);
        const batchSize = Math.min(APP.settings.maxConcurrentChunks, missingArray.length);
        
        for (let i = 0; i < batchSize; i++) {
          const chunkKey = missingArray[i];
          if (APP.downloadingChunks.has(chunkKey)) continue;
          
          const chunkIndex = parseInt(chunkKey.split('_')[1]);
          downloadChunkFromParallelTracker(chunkIndex, chunkKey);
        }
        
        if (APP.missingChunks.size > 0 && APP.downloadActive) {
          setTimeout(downloadChunks, APP.settings.chunkRequestInterval);
        }
      };
      
      downloadChunks();
    }    // **ENHANCED**: Download chunk using parallel tracker with better error handling
    async function downloadChunkFromParallelTracker(chunkIndex, chunkKey) {
      APP.downloadingChunks.add(chunkKey);
      
      try {
        log(`‚ö° Downloading chunk ${chunkIndex} via parallel tracker for ${APP.currentMovie}`, 'info');
        
        const response = await fetch(
          `${SERVER_URL}/parallel/download_chunk_parallel?movie=${encodeURIComponent(APP.currentMovie)}&chunkIndex=${chunkIndex}&peerId=${APP.localId}`,
          { 
            signal: AbortSignal.timeout(45000), // Increased timeout
            headers: { 'Cache-Control': 'no-cache' }
          }
        );
        
        if (response.ok) {
          const arrayBuffer = await response.arrayBuffer();
          const chunkData = new Uint8Array(arrayBuffer);
          const source = response.headers.get('X-Chunk-Source') || 'parallel';
          
          // Validate chunk data
          if (chunkData.length === 0) {
            throw new Error('Received empty chunk data');
          }
          
          receiveChunk(chunkIndex, chunkData, source);
          log(`‚úÖ Downloaded chunk ${chunkIndex} via parallel tracker (${formatBytes(chunkData.length)}) - Source: ${source}`, 'success');
        } else {
          // Parse error response
          let errorDetails = 'Unknown error';
          try {
            const errorData = await response.json();
            errorDetails = errorData.error || errorData.message || `HTTP ${response.status}`;
            
            // Check if it's a "no torrent" error
            if (errorDetails.includes('No torrent available') || errorDetails.includes('no magnet link')) {
              log(`‚ùå Parallel tracker has no torrent for ${APP.currentMovie} - chunk ${chunkIndex}`, 'error');
              log(`üí° Tip: Make sure the magnet link was stored properly`, 'info');
            }
          } catch (parseError) {
            errorDetails = `HTTP ${response.status}: ${response.statusText}`;
          }
          
          throw new Error(errorDetails);
        }
      } catch (err) {
        log(`‚ùå Parallel download failed for chunk ${chunkIndex}: ${err.message}`, 'error');
        APP.downloadingChunks.delete(chunkKey);
        
        // Fallback to regular server with delay
        setTimeout(() => {
          if (APP.downloadingChunks.has(chunkKey)) return; // Already downloading
          if (!APP.downloadActive) return; // Download stopped
          
          log(`üîÑ Falling back to regular tracker for chunk ${chunkIndex}`, 'info');
          downloadChunkFromServer(chunkIndex, chunkKey);
        }, 3000);
      }
    }

    // **NEW**: Handle parallel stream events and update UI
    function handleParallelStreamStarted(data) {
      const { movie, streamId, stats } = data;
      log(`üöÄ Parallel streaming engine started for ${movie}`, 'success');
      
      APP.parallelStreaming.engineActive = true;
      APP.parallelStreaming.currentStream = movie;
      
      if (stats) {
        APP.parallelStreaming.stats = { ...APP.parallelStreaming.stats, ...stats };
        updateParallelStreamingUI();
      }
    }

    function handleParallelStreamError(data) {
      const { movie, error } = data;
      log(`‚ùå Parallel streaming error for ${movie}: ${error}`, 'error');
      APP.parallelStreaming.engineActive = false;
      updateParallelStreamingUI();
    }

    function handleStreamingProgressUpdate(data) {
      const { movie, stats } = data;
      if (movie === APP.parallelStreaming.currentStream) {
        APP.parallelStreaming.stats = { ...APP.parallelStreaming.stats, ...stats };
        updateParallelStreamingUI();
        
        // Also update regular progress
        updateProgress();
        updateChunkVisualization();
      }
    }

    function handleStreamingStats(data) {
      const { stats } = data;
      if (stats) {
        APP.parallelStreaming.stats = { ...APP.parallelStreaming.stats, ...stats };
        updateParallelStreamingUI();
      }
    }

    // Event listeners
    document.getElementById('searchBtn').addEventListener('click', () => {
      const query = document.getElementById('searchInput').value.trim();
      if (query) {
        searchMovies(query);
      }
    });
    
    document.getElementById('searchInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const query = e.target.value.trim();
        if (query) {
          searchMovies(query);
        }
      }
    });

    // Parallel streaming button event listeners
    document.getElementById('enableParallelBtn').addEventListener('click', () => {
      if (!APP.parallelStreaming.enabled) {
        APP.parallelStreaming.enabled = true;
        document.getElementById('parallelStreamingPanel').style.display = 'block';
        log('üöÄ Parallel streaming mode enabled', 'success');
      } else {
        log('‚ö†Ô∏è Parallel streaming already enabled', 'warning');
      }
    });

    document.getElementById('viewStatsBtn').addEventListener('click', () => {
      if (APP.parallelStreaming.currentStream) {
        APP.socket.emit('getStreamingStats', { movie: APP.parallelStreaming.currentStream });
      } else {
        log('‚ö†Ô∏è No active streaming session', 'warning');
      }
    });

    document.getElementById('optimizeBtn').addEventListener('click', () => {
      // Auto-optimize parallel streaming settings
      const cpuCores = navigator.hardwareConcurrency || 4;
      APP.settings.maxConcurrentChunks = Math.min(cpuCores * 2, 10);
      log(`‚ö° Auto-optimized for ${cpuCores} CPU cores - Max concurrent chunks: ${APP.settings.maxConcurrentChunks}`, 'success');
    });

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      initializeSocket();
      updateConnectionStatus();
      log('üöÄ Optimized P2P Movie Platform initialized', 'success');
      log('üí° Open multiple browser tabs to test real P2P functionality!', 'info');
      
      // Periodic status updates
      setInterval(() => {
        if (APP.downloadActive) {
          updateDownloadSpeed();
          updateConnectionStatus();
        }
      }, 1000);
    });    // Make functions available globally
    window.startDownload = startDownload;
    window.startNewDownload = startNewDownload;
    window.startDownloadWithParallelStreaming = startDownloadWithParallelStreaming;
  </script>
</body>
</html>
